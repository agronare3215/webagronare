#!/usr/bin/env python3
"""
Replace inline style="..." in .html files by generated classes and append
the corresponding CSS to assets/css/styles.css.

Creates backups file.html.bak before modifying.
"""

import re
import os
import hashlib
from pathlib import Path

ROOT = Path('.')  # repo root
CSS_PATH = ROOT / 'assets' / 'css' / 'styles.css'
FILES_GLOB = ['**/*.html']  # which files to process

STYLE_RE = re.compile(r'(<[a-zA-Z0-9:_-]+\b[^>]*?)\sstyle\s*=\s*"([^"]*?)"(.*?)>', re.DOTALL)

def style_to_classname(style_text: str) -> str:
    h = hashlib.sha1(style_text.encode('utf-8')).hexdigest()[:8]
    return f'is-{h}'

def normalize_style(style_text: str) -> str:
    # ensure each property ends with a semicolon and trim whitespace
    props = [p.strip() for p in style_text.split(';') if p.strip()]
    return ';\n  '.join(props) + (';' if props else '')

def ensure_css_file():
    CSS_PATH.parent.mkdir(parents=True, exist_ok=True)
    if not CSS_PATH.exists():
        CSS_PATH.write_text("/* autogenerated styles (inline -> classes) */\n\n", encoding='utf-8')

def append_css_rule(classname: str, style_text: str):
    normalized = normalize_style(style_text)
    rule = f".{classname} {{\n  {normalized}\n}}\n\n"
    content = CSS_PATH.read_text(encoding='utf-8')
    if f".{classname} " in content or f".{classname}{{" in content:
        return False  # already present
    with CSS_PATH.open('a', encoding='utf-8') as f:
        f.write(rule)
    return True

def process_file(path: Path):
    text = path.read_text(encoding='utf-8')
    found = list(STYLE_RE.finditer(text))
    if not found:
        return False, 0

    # backup
    bak = path.with_suffix(path.suffix + '.bak')
    if not bak.exists():
        bak.write_bytes(path.read_bytes())

    replacements = {}
    def repl(m):
        before = m.group(1)
        style = m.group(2).strip()
        after = m.group(3)
        classname = style_to_classname(style)
        # create CSS rule if not yet appended
        if classname not in replacements:
            replacements[classname] = style

        # check if "class" exists in 'after' or before part
        # Merge into existing class attr if present
        class_attr_re = re.compile(r'\bclass\s*=\s*"([^"]*)"')
        whole_tag = before + after
        ca = class_attr_re.search(whole_tag)
        if ca:
            # replace only first occurrence of class="..."
            old_class = ca.group(1)
            new_class = old_class + ' ' + classname
            # replace in the correct position (in the whole matched tag)
            # build replacement of the matched tag parts:
            # we will reconstruct: before + (after with class replaced) + >
            after_replaced = class_attr_re.sub('class="' + new_class + '"', after, count=1)
            return before + after_replaced + '>'
        else:
            # insert new class attribute at the end of 'before' (before any other attrs in after)
            # we must preserve any leading space
            return before + ' class="' + classname + '"' + after + '>'
    new_text = STYLE_RE.sub(repl, text)

    # write file
    path.write_text(new_text, encoding='utf-8')

    # append css rules after processing to avoid duplicates
    added = 0
    for cls, style in replacements.items():
        if append_css_rule(cls, style):
            added += 1

    return True, len(replacements)

def main():
    ensure_css_file()
    total_files = 0
    total_replacements = 0
    for pattern in FILES_GLOB:
        for p in ROOT.glob(pattern):
            # skip node_modules, .git etc
            if any(part in ('node_modules', '.git', 'dist') for part in p.parts):
                continue
            ok, count = process_file(p)
            if ok:
                total_files += 1
                total_replacements += count
                print(f"[OK] {p} -> {count} unique inline styles replaced")
    print(f"\nDone. Files modified: {total_files}. New CSS rules appended (unique): {total_replacements}.")
    print(f"CSS file: {CSS_PATH.resolve()}")
    print("Backups created with .bak suffix next to original files.")

if __name__ == '__main__':
    main()
